"""
测试channelMapping函数的pytest测试文件
使用fpgamapping_for_func_709.py中a-h字典的angleDictList数据作为测试输入
"""

import pytest
import sys
import os
import json
import numbers
import pandas as pd
import numpy as np

# 添加父目录到Python路径，以便导入模块
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from idgenerate import channelMapping

# 测试数据：从fpgamapping_for_func_709.py中提取的a-h字典的angleDictList[0]
test_data_a = {"(0, 0)":3.1416,"(0, 1)":0.9273,"(0, 2)":2.1616,"(0, 3)":0.7752,"(0, 4)":4.3217,"(0, 5)":0.8798,"(0, 6)":1.9594,"(0, 7)":1.0247,"(0, 8)":5.4951,"(1, 0)":0.0752,"(1, 1)":1.7908,"(1, 2)":1.1645,"(1, 3)":2.5852,"(1, 4)":5.3348,"(1, 5)":1.7785,"(1, 6)":0.1508,"(1, 7)":2.5681,"(1, 8)":5.9047,"(2, 0)":2.3782,"(2, 1)":0.6377,"(2, 2)":1.2455,"(2, 3)":0.6841,"(2, 4)":2.3566,"(2, 5)":0.5719,"(2, 6)":5.8933,"(2, 7)":0.5361,"(2, 8)":1.3179,"(3, 0)":2.5703,"(3, 1)":3.1416,"(3, 2)":5.5034,"(3, 3)":3.1416,"(3, 4)":3.2802,"(3, 5)":3.1416,"(3, 6)":5.3868,"(3, 7)":3.1416,"(3, 8)":0.997,"(4, 0)":2.4963,"(4, 1)":3.1416,"(4, 2)":0.9728,"(4, 3)":3.1416,"(4, 4)":1.5785,"(4, 5)":3.1416,"(4, 6)":0.0168,"(4, 7)":3.1416,"(4, 8)":1.2189,"(5, 0)":1.1413,"(5, 1)":0.3674,"(5, 2)":5.4773,"(5, 3)":2.3519,"(5, 4)":4.7874,"(5, 5)":1.5155,"(5, 6)":3.9526,"(5, 7)":0.9273,"(5, 8)":4.6401,"(6, 0)":5.9447,"(6, 1)":1.4337,"(6, 2)":5.616,"(6, 3)":0.736,"(6, 4)":4.7445,"(6, 5)":1.569,"(6, 6)":4.4872,"(6, 7)":1.1817,"(6, 8)":6.2109,"(7, 0)":5.7472}

test_data_b = {"(0, 0)":3.1416,"(0, 1)":0.9273,"(0, 2)":3.7851,"(0, 3)":0.9273,"(0, 4)":6.1133,"(0, 5)":0.0,"(0, 6)":4.0969,"(0, 7)":1.231,"(0, 8)":1.7407,"(1, 0)":0.6435,"(1, 1)":3.1416,"(1, 2)":1.4009,"(1, 3)":0.0,"(1, 4)":4.4187,"(1, 5)":0.0,"(1, 6)":4.0969,"(1, 7)":3.1416,"(1, 8)":3.1416,"(2, 0)":1.1071,"(2, 1)":3.1416,"(2, 2)":3.4353,"(2, 3)":0.0,"(2, 4)":4.4187,"(2, 5)":0.0,"(2, 6)":0.0709,"(2, 7)":0.0,"(2, 8)":5.1051,"(3, 0)":6.1133,"(3, 1)":0.0,"(3, 2)":4.4187,"(3, 3)":0.0,"(3, 4)":0.0709,"(3, 5)":0.0,"(3, 6)":3.5343,"(3, 7)":0.0,"(3, 8)":0.0,"(4, 0)":2.3562,"(4, 1)":1.231,"(4, 2)":4.4187,"(4, 3)":0.0,"(4, 4)":0.0709,"(4, 5)":0.0,"(4, 6)":3.5343,"(4, 7)":0.0,"(4, 8)":0.0,"(5, 0)":0.9553,"(5, 1)":3.1416,"(5, 2)":0.0709,"(5, 3)":0.0,"(5, 4)":3.5343,"(5, 5)":0.0,"(5, 6)":2.6779,"(5, 7)":3.1416,"(5, 8)":2.0344,"(6, 0)":1.1781,"(6, 1)":3.1416,"(6, 2)":0.0,"(6, 3)":3.1416,"(6, 4)":3.5343,"(6, 5)":0.0,"(6, 6)":2.6779,"(6, 7)":3.1416,"(6, 8)":3.6052,"(7, 0)":4.7124}

test_data_c = {"(0, 0)":3.1416,"(0, 1)":0.9273,"(0, 2)":2.1616,"(0, 3)":0.7752,"(0, 4)":3.8728,"(0, 5)":0.0,"(0, 6)":6.2291,"(0, 7)":0.5148,"(0, 8)":0.4369,"(1, 0)":0.0752,"(1, 1)":1.7908,"(1, 2)":1.6793,"(1, 3)":0.5714,"(1, 4)":0.6889,"(1, 5)":0.3775,"(1, 6)":4.4335,"(1, 7)":1.8463,"(1, 8)":2.1708,"(2, 0)":2.3782,"(2, 1)":0.6377,"(2, 2)":0.1676,"(2, 3)":3.1416,"(2, 4)":2.8277,"(2, 5)":0.0484,"(2, 6)":3.2485,"(2, 7)":2.885,"(2, 8)":2.0286,"(3, 0)":4.5839,"(3, 1)":3.1416,"(3, 2)":4.3782,"(3, 3)":3.1416,"(3, 4)":1.8664,"(3, 5)":3.1416,"(3, 6)":5.0952,"(3, 7)":3.1416,"(3, 8)":4.1351,"(4, 0)":5.6989,"(4, 1)":1.4374,"(4, 2)":1.7654,"(4, 3)":2.0839,"(4, 4)":5.0042,"(4, 5)":0.056,"(4, 6)":1.8253,"(4, 7)":3.1416,"(4, 8)":2.9329,"(5, 0)":2.5276,"(5, 1)":0.6047,"(5, 2)":0.2438,"(5, 3)":0.0959,"(5, 4)":4.9677,"(5, 5)":0.9516,"(5, 6)":1.365,"(5, 7)":0.9273,"(5, 8)":0.8326,"(6, 0)":4.515,"(6, 1)":0.1164,"(6, 2)":1.2684,"(6, 3)":0.0347,"(6, 4)":0.2796,"(6, 5)":1.2531,"(6, 6)":0.8115,"(6, 7)":1.1817,"(6, 8)":2.4034,"(7, 0)":1.9397}

test_data_d = {"(0, 0)":3.1416,"(0, 1)":0.9273,"(0, 2)":2.1616,"(0, 3)":0.7752,"(0, 4)":0.3973,"(0, 5)":2.2851,"(0, 6)":5.5858,"(0, 7)":0.5201,"(0, 8)":6.0942,"(1, 0)":0.0752,"(1, 1)":1.7908,"(1, 2)":0.0559,"(1, 3)":1.7818,"(1, 4)":6.2621,"(1, 5)":2.1216,"(1, 6)":2.8203,"(1, 7)":1.9891,"(1, 8)":5.949,"(2, 0)":2.3782,"(2, 1)":0.6377,"(2, 2)":2.6235,"(2, 3)":1.7728,"(2, 4)":3.1918,"(2, 5)":2.3735,"(2, 6)":3.8329,"(2, 7)":0.9246,"(2, 8)":2.7543,"(3, 0)":0.0543,"(3, 1)":3.1416,"(3, 2)":2.1621,"(3, 3)":3.1416,"(3, 4)":6.2471,"(3, 5)":3.1416,"(3, 6)":3.1222,"(3, 7)":3.1416,"(3, 8)":4.8725,"(4, 0)":2.593,"(4, 1)":0.0,"(4, 2)":0.9825,"(4, 3)":3.1416,"(4, 4)":2.5452,"(4, 5)":3.1416,"(4, 6)":3.1368,"(4, 7)":3.1416,"(4, 8)":1.1894,"(5, 0)":6.2017,"(5, 1)":0.4204,"(5, 2)":5.6249,"(5, 3)":1.9361,"(5, 4)":5.3593,"(5, 5)":1.4496,"(5, 6)":2.3926,"(5, 7)":0.9273,"(5, 8)":6.1707,"(6, 0)":5.1914,"(6, 1)":0.6984,"(6, 2)":0.5219,"(6, 3)":1.3123,"(6, 4)":1.5353,"(6, 5)":2.9827,"(6, 6)":2.8838,"(6, 7)":1.1817,"(6, 8)":1.4583,"(7, 0)":0.9947}

test_data_e = {"(0, 0)":3.1416,"(0, 1)":3.1416,"(0, 2)":3.927,"(0, 3)":0.0,"(0, 4)":5.4978,"(0, 5)":0.0,"(0, 6)":5.4978,"(0, 7)":0.0,"(0, 8)":2.3562,"(1, 0)":2.3562,"(1, 1)":0.0,"(1, 2)":0.7854,"(1, 3)":0.0,"(1, 4)":0.7854,"(1, 5)":0.0,"(1, 6)":0.7854,"(1, 7)":0.0,"(1, 8)":3.1416,"(2, 0)":2.3562,"(2, 1)":3.1416,"(2, 2)":0.7854,"(2, 3)":0.0,"(2, 4)":0.7854,"(2, 5)":0.0,"(2, 6)":0.7854,"(2, 7)":0.0,"(2, 8)":3.1416,"(3, 0)":3.1416,"(3, 1)":0.0,"(3, 2)":0.7854,"(3, 3)":0.0,"(3, 4)":0.7854,"(3, 5)":0.0,"(3, 6)":4.7124,"(3, 7)":0.0,"(3, 8)":4.7124,"(4, 0)":3.1416,"(4, 1)":3.1416,"(4, 2)":0.7854,"(4, 3)":0.0,"(4, 4)":0.7854,"(4, 5)":0.0,"(4, 6)":4.7124,"(4, 7)":0.0,"(4, 8)":4.7124,"(5, 0)":3.927,"(5, 1)":0.0,"(5, 2)":0.7854,"(5, 3)":0.0,"(5, 4)":4.7124,"(5, 5)":0.0,"(5, 6)":4.7124,"(5, 7)":0.0,"(5, 8)":0.0,"(6, 0)":3.927,"(6, 1)":3.1416,"(6, 2)":0.7854,"(6, 3)":0.0,"(6, 4)":4.7124,"(6, 5)":0.0,"(6, 6)":4.7124,"(6, 7)":0.0,"(6, 8)":0.0,"(7, 0)":1.5708}

test_data_f = {"(0, 0)":3.1416,"(0, 1)":0.9273,"(0, 2)":1.1071,"(0, 3)":2.2143,"(0, 4)":5.0061,"(0, 5)":0.0,"(0, 6)":1.348,"(0, 7)":1.9106,"(0, 8)":0.2228,"(1, 0)":1.1071,"(1, 1)":3.1416,"(1, 2)":0.2937,"(1, 3)":0.0,"(1, 4)":4.8114,"(1, 5)":0.0,"(1, 6)":0.6155,"(1, 7)":3.1416,"(1, 8)":0.3927,"(2, 0)":2.0344,"(2, 1)":0.0,"(2, 2)":6.1133,"(2, 3)":0.0,"(2, 4)":4.8114,"(2, 5)":0.0,"(2, 6)":0.0709,"(2, 7)":0.0,"(2, 8)":4.7124,"(3, 0)":2.508,"(3, 1)":0.0,"(3, 2)":4.8114,"(3, 3)":0.0,"(3, 4)":0.0709,"(3, 5)":0.0,"(3, 6)":0.3927,"(3, 7)":0.0,"(3, 8)":2.7489,"(4, 0)":2.3562,"(4, 1)":1.231,"(4, 2)":4.8114,"(4, 3)":0.0,"(4, 4)":0.0709,"(4, 5)":0.0,"(4, 6)":0.3927,"(4, 7)":0.0,"(4, 8)":2.7489,"(5, 0)":1.348,"(5, 1)":3.1416,"(5, 2)":0.0709,"(5, 3)":0.0,"(5, 4)":0.3927,"(5, 5)":0.0,"(5, 6)":2.6779,"(5, 7)":3.1416,"(5, 8)":4.7833,"(6, 0)":1.9635,"(6, 1)":0.0,"(6, 2)":3.1416,"(6, 3)":3.1416,"(6, 4)":0.3927,"(6, 5)":0.0,"(6, 6)":5.8195,"(6, 7)":3.1416,"(6, 8)":3.2125,"(7, 0)":1.1781}

test_data_g = {"(0, 0)":3.1416,"(0, 1)":0.9273,"(0, 2)":2.1616,"(0, 3)":0.7752,"(0, 4)":4.5814,"(0, 5)":0.0,"(0, 6)":3.5101,"(0, 7)":0.4058,"(0, 8)":6.0066,"(1, 0)":0.0752,"(1, 1)":1.7908,"(1, 2)":5.0291,"(1, 3)":2.4696,"(1, 4)":2.7194,"(1, 5)":1.1916,"(1, 6)":1.4848,"(1, 7)":0.1359,"(1, 8)":0.5048,"(2, 0)":2.3782,"(2, 1)":0.6377,"(2, 2)":6.0829,"(2, 3)":3.1416,"(2, 4)":2.2606,"(2, 5)":2.3476,"(2, 6)":1.4567,"(2, 7)":0.4621,"(2, 8)":1.1654,"(3, 0)":5.3608,"(3, 1)":3.1416,"(3, 2)":2.0493,"(3, 3)":3.1416,"(3, 4)":0.4817,"(3, 5)":3.1416,"(3, 6)":4.3732,"(3, 7)":3.1416,"(3, 8)":0.0063,"(4, 0)":0.2013,"(4, 1)":1.181,"(4, 2)":6.2061,"(4, 3)":1.1112,"(4, 4)":3.9428,"(4, 5)":1.7086,"(4, 6)":6.1751,"(4, 7)":3.1416,"(4, 8)":3.5119,"(5, 0)":3.3083,"(5, 1)":0.8072,"(5, 2)":4.7199,"(5, 3)":1.5873,"(5, 4)":1.6561,"(5, 5)":0.7129,"(5, 6)":2.4643,"(5, 7)":0.9273,"(5, 8)":4.4532,"(6, 0)":3.3588,"(6, 1)":0.5293,"(6, 2)":4.3088,"(6, 3)":1.9335,"(6, 4)":5.2119,"(6, 5)":2.2621,"(6, 6)":3.495,"(6, 7)":1.1817,"(6, 8)":6.024,"(7, 0)":5.5603}

test_data_h = {"(0, 0)":3.1416,"(0, 1)":0.0,"(0, 2)":4.7124,"(0, 3)":0.0,"(0, 4)":4.7124,"(0, 5)":0.0,"(0, 6)":4.7124,"(0, 7)":0.0,"(0, 8)":1.5708,"(1, 0)":0.0,"(1, 1)":0.0,"(1, 2)":6.2832,"(1, 3)":0.0,"(1, 4)":6.2832,"(1, 5)":0.0,"(1, 6)":4.7124,"(1, 7)":0.0,"(1, 8)":4.7124,"(2, 0)":3.1416,"(2, 1)":0.0,"(2, 2)":0.0,"(2, 3)":0.0,"(2, 4)":6.2832,"(2, 5)":0.0,"(2, 6)":4.7124,"(2, 7)":0.0,"(2, 8)":4.7124,"(3, 0)":0.0,"(3, 1)":0.0,"(3, 2)":6.2832,"(3, 3)":0.0,"(3, 4)":4.7124,"(3, 5)":0.0,"(3, 6)":4.7124,"(3, 7)":0.0,"(3, 8)":0.0,"(4, 0)":3.1416,"(4, 1)":0.0,"(4, 2)":0.0,"(4, 3)":0.0,"(4, 4)":4.7124,"(4, 5)":0.0,"(4, 6)":4.7124,"(4, 7)":0.0,"(4, 8)":0.0,"(5, 0)":0.0,"(5, 1)":0.0,"(5, 2)":4.7124,"(5, 3)":0.0,"(5, 4)":4.7124,"(5, 5)":0.0,"(5, 6)":4.7124,"(5, 7)":0.0,"(5, 8)":1.5708,"(6, 0)":3.1416,"(6, 1)":0.0,"(6, 2)":4.7124,"(6, 3)":0.0,"(6, 4)":4.7124,"(6, 5)":0.0,"(6, 6)":4.7124,"(6, 7)":0.0,"(6, 8)":1.5708,"(7, 0)":3.1416}

# 将所有测试数据组织到一个列表中
test_datasets = [
    ("test_data_a", test_data_a),
    ("test_data_b", test_data_b),
    ("test_data_c", test_data_c),
    ("test_data_d", test_data_d),
    ("test_data_e", test_data_e),
    ("test_data_f", test_data_f),
    ("test_data_g", test_data_g),
    ("test_data_h", test_data_h),
]


def unify_to_float(d):
    """
    彊~J嬾W佅¸轇~L彉~@彜~I录°佀¼佞~K﻾Hint / float / numpy scalar﻾I纾_䷾@彈~P Python float⽀~B
    轝~^录°佀¼低~_庠·侾]潕~Y⽀~B
    """
    new_dict = {}
    for k, v in d.items():
        # 佈¤彖­彘¯佐¦彘¯ὀ~\录°佀¼佞~Kὀ~]﻾Z但~E置录°嬾W彈~V numpy 录°嬾W
        if isinstance(v, (int, float)):
            new_dict[k] = float(v)
        elif isinstance(v, numbers.Number):        # 襾F潛~V numpy 庠~G轇~O笾I
            new_dict[k] = float(v)
        else:
            new_dict[k] = v      # 轝~^录°嬾W低~_庠·侾]潕~Y
    return new_dict


class TestChannelMapping:
    """测试channelMapping函数的测试类"""
    
    @pytest.mark.parametrize("test_name,test_data", test_datasets)
    def test_channelMapping_output_structure(self, test_name, test_data):
        """
        测试channelMapping函数的输出结构
        验证输出是否为字典类型，包含预期的键
        """
        result = channelMapping(test_data)
        
        # 验证输出为字典
        assert isinstance(result, dict), f"{test_name}: 输出应该为字典类型"
        
        # 验证包含初始芯片配置中的所有键
        expected_keys = {318, 315, 494, 344, 188, 248, 59, 233}
        assert all(key in result for key in expected_keys), f"{test_name}: 应该包含所有初始芯片配置键"
        
        # 验证所有值都是数值类型（int或float）
        for key, value in result.items():
            assert isinstance(value, (int, float)), f"{test_name}: 键 {key} 的值应该是数值类型"
    
    @pytest.mark.parametrize("test_name,test_data", test_datasets)
    def test_channelMapping_current_values_range(self, test_name, test_data):
        """
        测试channelMapping函数输出的电流值范围
        验证电流值在合理范围内（通常在0-10之间）
        """
        result = channelMapping(test_data)
        
        for key, value in result.items():
            # 验证电流值在合理范围内
            assert 0 <= value <= 10, f"{test_name}: 通道 {key} 的电流值 {value} 超出合理范围 [0, 10]"
    
    @pytest.mark.parametrize("test_name,test_data", test_datasets)
    def test_channelMapping_angle_processing(self, test_name, test_data):
        """
        测试channelMapping函数对角度参数的处理
        验证函数能够正确处理字符串键和数值角度值
        """
        # 测试函数不抛出异常
        try:
            result = channelMapping(test_data)
            # 验证结果不为空
            assert len(result) > 0, f"{test_name}: 结果字典不应为空"
        except Exception as e:
            pytest.fail(f"{test_name}: channelMapping函数执行失败: {e}")
    
    def test_channelMapping_empty_input(self):
        """
        测试channelMapping函数对空输入的处理
        """
        result = channelMapping({})
        
        # 验证输出包含初始配置
        expected_keys = {318, 315, 494, 344, 188, 248, 59, 233}
        assert all(key in result for key in expected_keys), "空输入时应该返回初始芯片配置"
        
        # 验证初始配置值正确
        expected_values = {318:4.058497726043174, 315:4.063318014559033, 494:3.272454730430581, 
                          344:3.274430129969252, 188:5.697960978812926, 248:4.791060273531107, 
                          59:6.084469360272778, 233:4.602943995908386}
        for key, expected_value in expected_values.items():
            assert abs(result[key] - expected_value) < 1e-10, f"初始配置值不正确: 键 {key}"
    
    def test_channelMapping_invalid_keys_filtering(self):
        """
        测试channelMapping函数对无效键的过滤
        验证以'8'结尾和以'7'或'b'开头的键被正确过滤
        """
        # 创建包含有效和无效键的测试数据
        test_data = {
            "(0,0)": 1.0,  # 有效
            "(0,8)": 2.0,  # 无效（以8结尾）
            "(7,0)": 3.0,  # 无效（以7开头）
            "(b,0)": 4.0,  # 无效（以b开头）
            "(1,1)": 5.0,  # 有效
        }

        result = channelMapping(test_data)

        # 获取初始配置
        initial_config = {318:4.058497726043174, 315:4.063318014559033, 494:3.272454730430581,
                         344:3.274430129969252, 188:5.697960978812926, 248:4.791060273531107,
                         59:6.084469360272778, 233:4.602943995908386}

        # 由于无效键被过滤，某些通道的值应该保持初始值
        # 这里我们只验证函数能正常执行，不抛出异常
        assert isinstance(result, dict), "应该返回字典结果"
        assert len(result) >= len(initial_config), "结果至少包含初始配置"

    @pytest.mark.parametrize("test_name,test_data", test_datasets)
    def test_channelMapping_result_verification(self, test_name, test_data):
        """
        测试channelMapping函数的结果验证
        将channelMapping的输出结果经过unify_to_float处理后与对应的json文件进行比较
        """
        # 获取对应的json文件名
        json_filename = f"{test_name}.json"
        json_filepath = os.path.join(os.path.dirname(__file__), json_filename)

        # 验证json文件存在
        assert os.path.exists(json_filepath), f"对应的JSON文件不存在: {json_filename}"

        # 读取预期的结果
        with open(json_filepath, 'r', encoding='utf-8') as f:
            expected_result = json.load(f)

        # 调用channelMapping函数
        actual_result = channelMapping(test_data)

        # 对实际结果进行unify_to_float处理
        processed_result = unify_to_float(actual_result)

        # 比较结果
        assert len(processed_result) == len(expected_result), f"{test_name}: 结果字典长度不匹配"

        # 比较每个键值对（允许一定的浮点数精度误差）
        for key in expected_result.keys():
            if isinstance(key,str): key_int = int(key)
            assert key_int in processed_result, f"{test_name}: 缺少键 {key}"

            expected_value = expected_result[key]
            actual_value = processed_result[key_int]

            # 对于数值类型，使用近似比较处理浮点数精度问题
            if isinstance(expected_value, (int, float)) and isinstance(actual_value, (int, float)):
                assert abs(expected_value - actual_value) < 1e-10, \
                    f"{test_name}: 键 {key} 的值不匹配，预期: {expected_value}, 实际: {actual_value}"
            else:
                # 对于非数值类型，直接比较
                assert expected_value == actual_value, \
                    f"{test_name}: 键 {key} 的值不匹配，预期: {expected_value}, 实际: {actual_value}"

        # 验证没有额外的键
        for key_int in processed_result.keys():
            key = str(key_int)
            assert key in expected_result, f"{test_name}: 存在额外的键 {key}"
